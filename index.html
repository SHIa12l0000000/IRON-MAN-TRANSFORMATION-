<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hybrid Nanotech Transform — Portrait (No Sound)</title>
<style>
  :root{ --stage-w:360px; --stage-h:720px; --cube-size:6px; }
  html,body{height:100%;margin:0;background:#04040a;display:flex;align-items:center;justify-content:center;font-family:Inter,system-ui,Roboto,Arial;color:#dfeeff}
  .stage{
    width:var(--stage-w); height:var(--stage-h); border-radius:16px; overflow:hidden; position:relative;
    background:radial-gradient(800px 400px at 50% 30%, rgba(6,18,30,0.55), #000 44%);
    box-shadow: 0 30px 70px rgba(0,0,0,.7); perspective:1200px;
  }
  .scene{position:absolute;inset:0;transform-style:preserve-3d;overflow:hidden}
  .player-wrap{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:6;pointer-events:none}
  #playerImg{max-width:64%;height:auto;display:block;filter:drop-shadow(0 26px 40px rgba(0,0,0,.85));cursor:crosshair;border-radius:8px}
  .world{position:absolute;inset:0;transform-style:preserve-3d;pointer-events:none;z-index:7}
  .cube{position:absolute;width:var(--cube-size);height:var(--cube-size);transform-style:preserve-3d;border-radius:1px;will-change:transform,opacity;box-shadow:0 0 8px rgba(0,0,0,0.45) inset;opacity:0;mix-blend-mode:screen;}
  canvas.sparks{position:absolute;inset:0;z-index:12;pointer-events:none}
  canvas.holo{position:absolute;inset:0;z-index:9;pointer-events:none}
  .reactor{position:absolute;width:34px;height:34px;border-radius:999px;z-index:14;pointer-events:none;mix-blend-mode:screen;opacity:0;transform:translate(-50%,-50%)}
  .reactor::before{content:"";position:absolute;inset:0;border-radius:50%;box-shadow:0 0 36px 14px rgba(60,220,255,0.14),0 0 110px 36px rgba(0,150,255,0.06);background:radial-gradient(circle at 40% 35%, rgba(200,255,255,1) 0%, rgba(0,160,255,0.85) 28%, rgba(0,70,120,0.18) 70%);}
  .burstFlash{position:absolute;left:0;right:0;top:0;height:100%;z-index:15;pointer-events:none;mix-blend-mode:screen;opacity:0}
  .ui{position:absolute;left:12px;right:12px;bottom:12px;display:flex;justify-content:center;gap:8px;z-index:999}
  .btn{padding:10px 14px;border-radius:10px;border:none;font-weight:800;cursor:pointer}
  .btn.primary{background:linear-gradient(180deg,#ff6b26,#dd2b00);color:#fff}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.06);color:#cfe}
  .status{position:absolute;left:0;right:0;top:10px;text-align:center;color:#8ee;z-index:999;font-weight:700}
  .controls{position:absolute;left:12px;top:44px;z-index:1000;display:flex;gap:6px;align-items:center}
  .file-input{background:rgba(255,255,255,0.03);padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);color:#9fe;font-size:12px;cursor:pointer}
  .toggle{background:rgba(255,255,255,0.02);padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);color:#9fe;font-size:12px;cursor:pointer}
  .marker{position:absolute;width:22px;height:22px;border-radius:50%;z-index:998;pointer-events:none;transform:translate(-50%,-50%);opacity:0}
  .marker::before{content:"";position:absolute;inset:0;border-radius:50%;box-shadow:0 0 18px 8px rgba(0,200,255,0.12),0 0 50px 20px rgba(0,140,255,0.06);background:radial-gradient(circle at 40% 35%, rgba(200,255,255,1) 0%, rgba(0,120,255,0.6) 30%);}
  .shake{animation:shakevar 420ms linear 1}
  @keyframes shakevar{0%{transform:translate(-50%,-50%) translateZ(0) rotateX(0)}25%{transform:translate(-50%,-50%) translateZ(0) rotateZ(-0.6deg)}50%{transform:translate(-50%,-50%) translateZ(0) rotateZ(0.6deg)}75%{transform:translate(-50%,-50%) translateZ(0) rotateZ(-0.3deg)}100%{transform:translate(-50%,-50%) translateZ(0) rotateX(0)}}
  @media (min-width:900px){:root{--stage-w:420px;--stage-h:820px}}
</style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="status" id="status">Choose Player & Suit images, click the player to set chest, pick Detail, then press TRANSFORM.</div>

    <div class="scene" id="scene">
      <div class="player-wrap" id="playerWrap">
        <img id="playerImg" src="" alt="player (click to set chest)">
      </div>

      <div class="world" id="world"></div>

      <canvas id="holoCanvas" class="holo"></canvas>
      <canvas id="sparks" class="sparks"></canvas>

      <div class="reactor" id="reactor" aria-hidden="true"></div>
      <div class="burstFlash" id="burstFlash"></div>

      <canvas id="suitSampler" style="display:none"></canvas>
      <img id="suitImg" src="" style="display:none">
      <div class="marker" id="marker"></div>
    </div>

    <div class="controls">
      <label class="file-input">Player
        <input id="playerFile" type="file" accept="image/*" style="display:none">
      </label>
      <label class="file-input">Suit
        <input id="suitFile" type="file" accept="image/*" style="display:none">
      </label>
      <div class="toggle" id="detailToggle" title="Toggle detail">Detail: Normal</div>
    </div>

    <div class="ui">
      <button class="btn primary" id="transformBtn">Transform</button>
      <button class="btn ghost" id="resetBtn">Reset</button>
    </div>
  </div>

<script>
/* Hybrid portrait transform — no audio
   - Holographic scan (phase1)
   - Nanotech cube swirl (phase2)
   - Plasma burst & settle (phase3)
   - Click player image to set chest position
   - Detail toggle (Normal / High)
   - Tries default filenames but file input recommended
*/

const DEFAULT_PLAYER = '1000139367.png';
const DEFAULT_SUIT = '1000139366.png';

const CONFIG_BASE = {
  CUBE_SIZE: 6,
  SAMPLE_STEP_NORMAL: 8,
  SAMPLE_STEP_HIGH: 4,
  START_RADIUS: 600,
  ASSEMBLE_MS: 2200,
  STAGGER_FACTOR: 0.9,
  MAX_CUBES_NORMAL: 1400,
  MAX_CUBES_HIGH: 2500,
  SPARK_COUNT_NORMAL: 70,
  SPARK_COUNT_HIGH: 130,
  HOLO_MS: 900,
  BURST_MS: 600
};

let CONFIG = Object.assign({}, CONFIG_BASE);

const stage = document.getElementById('stage');
const world = document.getElementById('world');
const transformBtn = document.getElementById('transformBtn');
const resetBtn = document.getElementById('resetBtn');
const status = document.getElementById('status');
const playerImg = document.getElementById('playerImg');
const playerWrap = document.getElementById('playerWrap');
const suitImg = document.getElementById('suitImg');
const suitSampler = document.getElementById('suitSampler');
const sparksCanvas = document.getElementById('sparks');
const holoCanvas = document.getElementById('holoCanvas');
const reactor = document.getElementById('reactor');
const burstFlash = document.getElementById('burstFlash');
const playerFile = document.getElementById('playerFile');
const suitFile = document.getElementById('suitFile');
const detailToggle = document.getElementById('detailToggle');
const marker = document.getElementById('marker');

let cubes = [], assembling=false, cubeCount=0, sparkCtx=null, holoCtx=null;
let lastPlayerRect = null, chestPoint = null, detailHigh=false;

/* canvas sizing */
function resize() {
  sparksCanvas.width = stage.clientWidth;
  sparksCanvas.height = stage.clientHeight;
  holoCanvas.width = stage.clientWidth;
  holoCanvas.height = stage.clientHeight;
}
window.addEventListener('resize', resize);
resize();

/* helpers */
const rnd = (a,b)=> Math.random()*(b-a)+a;
const clamp = (v,a,b)=> Math.max(a,Math.min(b,v));

/* file inputs */
playerFile.addEventListener('change', e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const r = new FileReader(); r.onload = ev=> { playerImg.src = ev.target.result; status.innerText='Player loaded.'; };
  r.readAsDataURL(f);
});
suitFile.addEventListener('change', e=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const r = new FileReader(); r.onload = ev=> { suitImg.src = ev.target.result; status.innerText='Suit loaded.'; };
  r.readAsDataURL(f);
});
document.querySelectorAll('.file-input').forEach(el=>{
  el.addEventListener('click', evt=>{ const input = el.querySelector('input'); input.click(); evt.preventDefault(); });
});

/* detail toggle */
detailToggle.addEventListener('click', ()=>{ detailHigh = !detailHigh; detailToggle.textContent = 'Detail: ' + (detailHigh?'High':'Normal'); status.innerText = `Detail ${detailHigh?'High':'Normal'}`; });

/* chest click on player image */
playerImg.addEventListener('click', ev=>{
  const prect = playerImg.getBoundingClientRect();
  if(prect.width===0) return;
  const stageRect = stage.getBoundingClientRect();
  const sx = ev.clientX - stageRect.left;
  const sy = ev.clientY - stageRect.top;
  chestPoint = {x: sx, y: sy};
  // marker pulse
  marker.style.left = sx + 'px'; marker.style.top = sy + 'px';
  marker.style.opacity = 1;
  marker.style.transform = 'translate(-50%,-50%) scale(1.25)';
  setTimeout(()=> marker.style.transform = 'translate(-50%,-50%) scale(1)', 120);
  status.innerText = 'Chest target locked';
});

/* attempt to load defaults (will fail silently if blocked by browser) */
playerImg.src = DEFAULT_PLAYER;
suitImg.src = DEFAULT_SUIT;
status.innerText = 'Choose Player & Suit or use defaults (click player to set chest).';

/* sample suit image to positions */
function createCubesFromSuit(cb){
  if(!suitImg.complete || suitImg.naturalWidth===0){ suitImg.onload = ()=> createCubesFromSuit(cb); suitImg.onerror = ()=> status.innerText='Load suit (top-left)'; return; }
  resize();
  const sW = suitImg.naturalWidth, sH = suitImg.naturalHeight;
  const step = detailHigh ? CONFIG_BASE.SAMPLE_STEP_HIGH : CONFIG_BASE.SAMPLE_STEP_NORMAL;
  const maxCap = detailHigh ? CONFIG_BASE.MAX_CUBES_HIGH : CONFIG_BASE.MAX_CUBES_NORMAL;
  suitSampler.width = sW; suitSampler.height = sH;
  const sCtx = suitSampler.getContext('2d'); sCtx.clearRect(0,0,sW,sH); sCtx.drawImage(suitImg,0,0,sW,sH);
  const imgData = sCtx.getImageData(0,0,sW,sH).data;
  const positions = [];
  for(let y=0;y<sH;y+=step){
    for(let x=0;x<sW;x+=step){
      const idx = (y*sW+x)*4; const a = imgData[idx+3];
      if(a>30){ const r=imgData[idx], g=imgData[idx+1], b=imgData[idx+2]; positions.push({x,y,color:`rgb(${r},${g},${b})`}); }
    }
  }
  if(positions.length > maxCap){
    const stride = Math.ceil(positions.length/maxCap); const filtered=[];
    for(let i=0;i<positions.length;i+=stride) filtered.push(positions[i]);
    positions.length=0; positions.push(...filtered);
  }
  cb(positions);
}

/* map to player bounding box */
function mapToPlayer(positions){
  const playerRect = playerImg.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();
  if(playerRect.width===0) return [];
  lastPlayerRect = playerRect;
  const suitW = suitImg.naturalWidth, suitH = suitImg.naturalHeight;
  const scaleX = playerRect.width / suitW, scaleY = playerRect.height / suitH;
  const offsetX = playerRect.left - stageRect.left, offsetY = playerRect.top - stageRect.top;
  return positions.map(p=>({ tx: Math.round(p.x*scaleX + offsetX), ty: Math.round(p.y*scaleY + offsetY), color: p.color }));
}

/* build cube DOM */
function buildCubes(mapped){
  world.innerHTML=''; cubes=[];
  const W = stage.clientWidth, H = stage.clientHeight, centerX = W/2, centerY = H/2;
  mapped.forEach((m,i)=>{
    const el = document.createElement('div'); el.className='cube';
    el.style.width = CONFIG_BASE.CUBE_SIZE + 'px'; el.style.height = CONFIG_BASE.CUBE_SIZE + 'px';
    el.style.background = m.color; el.style.opacity='0';
    const theta = rnd(0,Math.PI*2), phi = rnd(0,Math.PI), r = rnd(120,CONFIG_BASE.START_RADIUS);
    const sx = centerX + r*Math.cos(theta)*Math.sin(phi), sy = centerY + r*Math.sin(theta)*Math.sin(phi), sz = rnd(-900,900);
    el.style.transform = `translate3d(${sx}px, ${sy}px, ${sz}px) scale(.8) rotateX(${rnd(-90,90)}deg) rotateY(${rnd(-90,90)}deg)`;
    world.appendChild(el);
    const targetChestX = chestPoint ? chestPoint.x : (m.tx + (CONFIG_BASE.CUBE_SIZE/2));
    const targetChestY = chestPoint ? chestPoint.y : (m.ty + (CONFIG_BASE.CUBE_SIZE/2));
    cubes.push({
      el, sx, sy, sz,
      tx: m.tx + (CONFIG_BASE.CUBE_SIZE/2),
      ty: m.ty + (CONFIG_BASE.CUBE_SIZE/2),
      tz: 0,
      chestX: targetChestX, chestY: targetChestY,
      index: i,
      delay: (i / mapped.length) * CONFIG_BASE.ASSEMBLE_MS * CONFIG_BASE.STAGGER_FACTOR * Math.random()
    });
  });
  cubeCount = cubes.length;
  status.innerText = `Cubes ready: ${cubeCount}. Click TRANSFORM.`;
}

/* Phase: Holographic scan (grid + polygons) */
function startHolographic(duration=CONFIG_BASE.HOLO_MS){
  holoCtx = holoCanvas.getContext('2d');
  const W = holoCanvas.width, H = holoCanvas.height;
  let start = performance.now();
  function frame(now){
    const t = (now - start)/duration;
    holoCtx.clearRect(0,0,W,H);
    // radial scan centered on chest or player center
    const cx = chestPoint ? chestPoint.x : W/2;
    const cy = chestPoint ? chestPoint.y : H/2;
    // scan ring
    const ringR = (Math.sin(t*Math.PI*2)+1)*30 + (1-t)*120;
    holoCtx.save();
    holoCtx.globalCompositeOperation = 'lighter';
    // soft radial glow
    const g = holoCtx.createRadialGradient(cx,cy,ringR*0.1,cx,cy,ringR*2);
    g.addColorStop(0,'rgba(120,220,255,'+ (0.45*(1-t)) +')');
    g.addColorStop(1,'rgba(0,80,120,0)');
    holoCtx.fillStyle = g; holoCtx.fillRect(0,0,W,H);
    // draw scanlines
    holoCtx.strokeStyle = 'rgba(140,230,255,0.12)'; holoCtx.lineWidth = 1;
    for(let y = cy - 180; y < cy + 180; y += 12){
      holoCtx.beginPath(); holoCtx.moveTo(cx-220,y); holoCtx.lineTo(cx+220,y); holoCtx.stroke();
    }
    // draw rotating polygons around chest
    const polyCount = 8;
    for(let i=0;i<polyCount;i++){
      const ang = now/600 + i*(Math.PI*2/polyCount);
      const rr = 40 + (i*6) + Math.sin(now/500 + i)*18*(1 - t);
      holoCtx.beginPath();
      for(let k=0;k<5;k++){
        const a = ang + k*(Math.PI*2/5);
        const x = cx + Math.cos(a)*rr;
        const y = cy + Math.sin(a)*rr;
        if(k===0) holoCtx.moveTo(x,y); else holoCtx.lineTo(x,y);
      }
      holoCtx.closePath();
      holoCtx.fillStyle = `rgba(60,200,255,${0.08 + 0.18*(1-t)})`;
      holoCtx.fill();
      holoCtx.strokeStyle = `rgba(160,255,255,${0.06 + 0.12*(1-t)})`;
      holoCtx.stroke();
    }
    holoCtx.restore();
    if(t < 1) requestAnimationFrame(frame);
    else { holoCtx.clearRect(0,0,W,H); }
  }
  requestAnimationFrame(frame);
}

/* Sparks (particles) */
function startSparks(){
  if(!sparkCtx) sparkCtx = sparksCanvas.getContext('2d');
  const W = sparksCanvas.width, H = sparksCanvas.height;
  const SC = detailHigh ? CONFIG_BASE.SPARK_COUNT_HIGH : CONFIG_BASE.SPARK_COUNT_NORMAL;
  const sparks = [];
  for(let i=0;i<SC;i++){
    sparks.push({ x: rnd(W*0.2,W*0.8), y: rnd(H*0.2,H*0.9), vx: rnd(-2.6,2.6), vy: rnd(-3.8,-0.3), life: rnd(240,1100), age: 0, size: rnd(1,3), alpha: rnd(0.18,0.85) });
  }
  let last = performance.now();
  function tick(now){
    const dt = now - last; last = now;
    sparkCtx.clearRect(0,0,W,H);
    for(let s of sparks){
      s.age += dt;
      if(s.age > s.life){ s.x = (chestPoint?chestPoint.x:W/2)+rnd(-60,60); s.y = (chestPoint?chestPoint.y:W/2)+rnd(-40,40); s.vx = rnd(-2,2); s.vy = rnd(-4,0); s.age=0; s.life = rnd(220,900); }
      s.x += s.vx * dt/16; s.y += s.vy * dt/16; s.vy += 0.04*dt/16;
      sparkCtx.globalAlpha = clamp((1 - s.age/s.life)*s.alpha,0,1);
      sparkCtx.beginPath(); sparkCtx.arc(s.x,s.y,s.size,0,Math.PI*2); sparkCtx.fillStyle = 'rgba(200,240,255,1)'; sparkCtx.fill();
    }
    if(assembling || cubes.length>0) requestAnimationFrame(tick);
    else sparkCtx.clearRect(0,0,W,H);
  }
  requestAnimationFrame(tick);
}

/* burst visual (plasma) */
function doBurst(){
  const el = burstFlash;
  el.style.background = 'radial-gradient(circle at center, rgba(255,255,240,0.95), rgba(255,180,120,0.6) 30%, rgba(160,220,255,0.08) 60%, rgba(0,0,0,0) 100%)';
  el.style.opacity = 0.0; el.style.transition = 'opacity 140ms ease-out, transform 480ms cubic-bezier(.2,.9,.2,1)';
  el.style.transform = 'scale(0.92)';
  requestAnimationFrame(()=>{ el.style.opacity = 1; el.style.transform = 'scale(1.06)'; });
  // shockwave ring using holo canvas overlay quickly
  const ctx = holoCanvas.getContext('2d'); const W = holoCanvas.width, H = holoCanvas.height;
  let start = performance.now();
  const duration = CONFIG_BASE.BURST_MS;
  const cx = chestPoint?chestPoint.x:W/2, cy = chestPoint?chestPoint.y:H/2;
  function anim(now){
    const t = (now-start)/duration;
    ctx.clearRect(0,0,W,H);
    if(t < 1){
      ctx.beginPath();
      ctx.arc(cx,cy, 60 + t*300, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(255,200,140,${1 - t})`;
      ctx.lineWidth = 6 * (1 - t) + 1;
      ctx.stroke();
      requestAnimationFrame(anim);
    } else { ctx.clearRect(0,0,W,H); }
  }
  requestAnimationFrame(anim);
  // fade burst
  setTimeout(()=>{ el.style.opacity = 0; setTimeout(()=> el.style.transform='scale(1)', 220); }, 140);
}

/* main assemble: cubes spiral toward chest then snap to mapped positions */
function animateAssemble(){
  if(assembling) return;
  assembling = true;
  const startTime = performance.now();
  // reactor placement
  if(chestPoint){
    reactor.style.left = chestPoint.x + 'px'; reactor.style.top = chestPoint.y + 'px';
  } else if(lastPlayerRect){
    const sr = stage.getBoundingClientRect();
    reactor.style.left = (lastPlayerRect.left - sr.left + lastPlayerRect.width/2) + 'px';
    reactor.style.top = (lastPlayerRect.top - sr.top + lastPlayerRect.height/2) + 'px';
  } else {
    reactor.style.left = (stage.clientWidth/2) + 'px'; reactor.style.top = (stage.clientHeight/2) + 'px';
  }
  reactor.style.opacity = 1; reactor.style.transform = 'translate(-50%,-50%) scale(1.3)';
  startSparks();

  playerWrap.classList.add('shake'); setTimeout(()=>playerWrap.classList.remove('shake'), CONFIG_BASE.CAMERA_SHAKE_MS);

  function step(now){
    const tGlobal = now - startTime;
    let allAtTarget=true;
    for(const c of cubes){
      const tLocal = clamp((tGlobal - c.delay)/CONFIG_BASE.ASSEMBLE_MS, 0, 1);
      const ease = 1 - Math.pow(1 - tLocal, 3);
      // spiral math
      const spiralTurns = 3.0;
      const idxPhase = (c.index % 100)/100;
      const angle = (1 - ease) * (spiralTurns * Math.PI * 2) + idxPhase * Math.PI * 2;
      const maxR = Math.max(12, Math.hypot(c.tx - c.chestX, c.ty - c.chestY));
      const spiralR = maxR * (1 - ease);
      const sOffX = Math.cos(angle) * spiralR;
      const sOffY = Math.sin(angle) * spiralR;
      const chestGoalX = c.chestX + sOffX;
      const chestGoalY = c.chestY + sOffY;
      const secondary = Math.pow(ease, 1.6);
      const interX = chestGoalX + (c.tx - chestGoalX) * secondary;
      const interY = chestGoalY + (c.ty - chestGoalY) * secondary;
      const curX = c.sx + (interX - c.sx) * ease;
      const curY = c.sy + (interY - c.sy) * ease;
      const curZ = c.sz + (c.tz - c.sz) * ease;
      const rot = (1 - ease) * 360;
      c.el.style.transform = `translate3d(${curX}px, ${curY}px, ${curZ}px) rotateX(${rot}deg) rotateY(${rot*0.7}deg) scale(${0.8 + 0.2*ease})`;
      c.el.style.opacity = `${0.16 + ease*0.84}`;
      if(tLocal < 1) allAtTarget = false;
    }
    if(!allAtTarget) requestAnimationFrame(step);
    else {
      // final micro effects
      assembling = false;
      doBurst();
      // brief settling: ensure reactor scales down
      reactor.style.transform = 'translate(-50%,-50%) scale(1)';
      status.innerText = 'Transformation complete';
      // small sparkle burst
      burstSparks(26);
      setTimeout(()=>{ /* leave cubes visible */ }, 300);
    }
  }
  requestAnimationFrame(step);
}

/* burst sparks function */
function burstSparks(n){
  if(!sparkCtx) sparkCtx = sparksCanvas.getContext('2d');
  const W = sparksCanvas.width, H = sparksCanvas.height;
  const cx = chestPoint ? chestPoint.x : W/2, cy = chestPoint ? chestPoint.y : H/2;
  const burst = []; for(let i=0;i<n;i++) burst.push({ x: cx, y: cy, vx: rnd(-8,8), vy: rnd(-10,2), life: rnd(300,900), age:0, size:rnd(1.2,3), alpha:1 });
  let last = pe
